@startuml mw_log_datarouter_recorder

class "DataRouterRecorder" as DataRouterRecorder {
  - backend_: std::unique_ptr<Backend>
  - config_: Configuration
  - statistics_reporter_: StatisticsReporter
  __
  + DataRouterRecorder(std::unique_ptr<Backend>&&, const Configuration&)
  + StartRecord(const std::string_view, const LogLevel): score::cpp::optional<SlotHandle>
  + StopRecord(const SlotHandle&): void
  + Log(const SlotHandle&, const T) - family of functions
  + IsLogEnabled(const LogLevel&, const std::string_view) : bool
  __
  - LogData(const SlotHandle&, const T data): void
  - SetApplicationId(LogRecord&): void
}

class "StatisticsReporter" as StatisticsReporter {
  - recorder_: Recorder&
  - report_interval_: std::chrono::seconds
  - number_of_slots_: std::size_t
  - slot_size_bytes_: std::size_t
  - no_slot_available_counter_: std::atomic<std::size_t>
  - message_too_long_counter_: std::atomic<std::size_t>
  - last_report_time_point_nanoseconds_: std::atomic<std::int64_t>
  - currently_reporting_: std::atomic_bool
  __
  + StatisticsReporter(Recorder&, const std::chrono::seconds,\n  const std::size_t, const std::size_t)
  + IncrementNoSlotAvailable(): void
  + IncrementMessageTooLong(): void
  + Update(const std::chrono::steady_clock::time_point&): void
}

interface "IStatisticsReporter" as IStatisticsReporter {
  + IncrementNoSlotAvailable(): void
  + IncrementMessageTooLong(): void
  + Update(const std::chrono::steady_clock::time_point&): void
}

class "Configuration" as Configuration {
}

class "DataRouterBackend" as DataRouterBackend {
}

class "Recorder" as Recorder {
}

class "mw::log::Runtime" as Runtime <<Singleton>> {
}

' Relationships
Runtime --> DataRouterRecorder : is owned by
DataRouterRecorder *-- StatisticsReporter
DataRouterRecorder *-- Configuration
DataRouterRecorder *-- DataRouterBackend
StatisticsReporter ..|> IStatisticsReporter
StatisticsReporter --> Recorder : uses

@enduml
