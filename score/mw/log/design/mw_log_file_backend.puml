@startuml mw_log_file_backend

' Classes
class "mw::log::Recorder" as Recorder {
  + StartRecord(ctx:std::string_view, ll:LogLevel): score::cpp::optional<SlotHandle>
  + StopRecord(slot:SlotHandle&)
  + Log( T data ) - family of functions
  __
  - backend:unique_ptr<mw::log::Backend>
  __
  Responsibilities:
  -- Opens and closes file.
  Uses formatters to serialize
  user data and header.
}

interface "mw::log::detail::Backend" as Backend {
  + ReserveSlot(): score::cpp::optional<SlotHandle>
  + FlushSlot(const SlotHandle&)
  + GetLogRecord(const SlotHandle&): LogRecord&
}

class "mw::log::detail::FileOutputBackend" as FileOutputBackend {
  - buffer_allocator_: std::unique_ptr<CircularAllocator<LogRecord>>
  - slot_drainer_:SlotDrainer
  __
  + FileOutputBackend(std::unique_ptr<IMessageBuilder>,\n  const std::int32_t,\n  std::unique_ptr<CircularAllocator<LogRecord>>,\n  std::unique_ptr<score::os::Fcntl>)
  + ReserveSlot():score::cpp::optional<SlotHandle>
  + FlushSlot(const SlotHandle&):void
  + GetLogRecord(const SlotHandle&): LogRecord&
  __
  Responsibilities
  -- keeps statistics of dropped messages
}

class "mw::log::detail::SlotDrainer" as SlotDrainer {
  - allocator_: std::unique_ptr<CircularAllocator<LogRecord>>&
  - message_builder_:std::unique_ptr<IMessageBuilder>
  - context_mutex_:std::mutex
  - circular_buffer_:score::cpp::circular_buffer<SlotHandle, kMaxCircularBufferSize>
  - current_slot_:score::cpp::optional<std::reference_wrapper<const SlotHandle>>
  - non_blocking_writer_: NonBlockingWriter
  - limit_slots_in_one_cycle_: const std::size_t
  __
  + SlotDrainer(std::unique_ptr<IMessageBuilder>,\n  std::unique_ptr<CircularAllocator<LogRecord>>&,\n  const std::int32_t,\n  const std::size_t,\n  std::unique_ptr<score::os::Unistd>)
  + PushBack(const SlotHandle&):void
  + Flush():void
  __
  - TryFlushSlots(): score::cpp::expected<FlushResult, score::mw::log::detail::Error>
  - TryFlushSpans(): score::cpp::expected<FlushResult, score::mw::log::detail::Error>
  - MoreSlotsAvailableAndLoaded():bool
  - MoreSpansAvailableAndLoaded():bool
  __
  Responsibilities
  -- Drains slots - empties circular_buffer
  when subsequent data has been flushed
  -- Returns status if data was flushed or stalled
}

class "mw::log::detail::NonBlockingWriter" as NonBlockingWriter {
  - unistd_: std::unique_ptr<score::os::Unistd>
  - file_handle_: std::int32_t
  - number_of_flushed_bytes_: uint64_t
  - buffer_: score::cpp::span<const std::uint8_t>
  - buffer_flushed_: Result
  - max_chunk_size_: std::size_t
  __
  + NonBlockingWriter(const std::int32_t, std::size_t, std::unique_ptr<score::os::Unistd>)
  + FlushIntoFile(): score::cpp::expected<Result, score::mw::log::detail::Error>
  + SetSpan(const score::cpp::span<const std::uint8_t>&): void
  + GetMaxChunkSize(): std::size_t
  __
  - InternalFlush(const uint64_t): score::cpp::expected<ssize_t, score::os::Error>
  __
  Responsibilities
  -- Write logs into file
}

interface "mw::log::detail::IMessageBuilder" as IMessageBuilder {
  + GetNextSpan() : score::cpp::optional<score::cpp::span<const std::uint8_t>>
  + SetNextMessage(LogRecord&): void
  __
  Responsibility:
  iterates over spans of data to be
  serialized into output stream.
}

class "mw::log::detail::DltMessageBuilder" as DltMessageBuilder {
  + DltMessageBuilder(ecu_id)
  + GetNextSpan() : score::cpp::optional<score::cpp::span<const std::uint8_t>>
  + SetNextMessage(LogRecord&): void
}

class "mw::log::detail::TextMessageBuilder" as TextMessageBuilder {
  + TextMessageBuilder(app_id, ecu_id, )
  + GetNextSpan() : score::cpp::optional<score::cpp::span<const std::uint8_t>>
  + SetNextMessage(log_record:LogRecord&): void
}

class "mw::log::detail::CircularAllocator<T>" as CircularAllocator {
  - claimed_sequence_:std::atomic<std::size_t>
  - buffer_:std::vector<Slot<T>>
  __
  + CircularAllocator(std::size_t, const T&)
  + AcquireSlotToWrite(): score::cpp::optional<std::size_t>
  + GetUnderlyingBufferFor(std::size_t): T&
  + ReleaseSlot(std::size_t):void
  + GetUsedCount():size_t
}

class "score::cpp::circular_buffer<T=SlotHandle,MaxSize>" as CircularBuffer {
  Responsibilities
  -- stores elements of static size
  -- overwrites data when full
  -- realizes FIFO pattern
}

class "mw::log::detail::Slot<T>" as Slot {
  + data: T
  + in_use: std::atomic<bool>
}

class "mw::log::detail::LogRecord" as LogRecord #Orange {
  - logEntry_:LogEntry
  - verbosePayload_:VerbosePayload
  __
  LogRecord(const std::size_t)
  getLogEntry(): LogEntry&
  getLogEntry(): const LogEntry&
  getVerbosePayload(): VerbosePayload&
  getVerbosePayload(): const VerbosePayload&
}

class "VerbosePayload" as VerbosePayload {
}

class "LoggingIdentifier" as LoggingIdentifier {
}

class "mw::log::detail::BackendLogMock" as BackendLogMock #Pink {
  + ReserveSlot(): score::cpp::optional<SlotHandle>
  + FlushSlot(const SlotHandle&)
  + GetLogRecord(const SlotHandle&): LogRecord&
}

class "OSAL::Unistd" as OsalUnistd1 {
}

class "OSAL::Unistd" as OsalUnistd2 {
}

class "OSAL::fcntl" as Fcntl {
}

' Relationships
Recorder *-- Backend
Backend <|.. FileOutputBackend
Backend <|.. BackendLogMock

FileOutputBackend *-- SlotDrainer
FileOutputBackend *-- CircularAllocator

SlotDrainer *-- NonBlockingWriter
SlotDrainer *-- CircularBuffer
SlotDrainer *-- CircularAllocator
SlotDrainer *-- IMessageBuilder

NonBlockingWriter *-- OsalUnistd1
NonBlockingWriter ..> OsalUnistd1 : write

IMessageBuilder <|-- DltMessageBuilder
IMessageBuilder <|-- TextMessageBuilder

CircularAllocator "0..n" *-- Slot
CircularAllocator ..> CircularAllocator : GetUnderlyingBufferFor()\nReleaseSlot()

FileOutputBackend ..> CircularAllocator : AcquireSlotToWrite()\nGetUnderlyingBufferFor()
SlotDrainer ..> CircularAllocator : GetUnderlyingBufferFor()\nReleaseSlot()

CircularBuffer ..> CircularAllocator : Created based on CircularAllocatorSize

DltMessageBuilder *-- LoggingIdentifier
DltMessageBuilder *-- VerbosePayload
TextMessageBuilder *-- LoggingIdentifier
TextMessageBuilder *-- VerbosePayload

Recorder ..> Fcntl : open\nSetNonBlocking / fctrl call
Recorder ..> OsalUnistd2 : close

' Notes
note right of NonBlockingWriter
  Test strategy:
  Inject OSAL mock
  by constructor argument
  with default value
end note

note right of FileOutputBackend
  Test strategy:
  Inject NonBlocking Writer
  and using OSAL mock
  Configure circular buffer size
  Use MessageBuilderMock
end note

note right of IMessageBuilder
  Test strategy:
  Insert the data, verify outcome
end note

note top of CircularBuffer
  Test strategy:
  using score::cpp::circular_buffer
  not tested here
end note

note bottom of CircularBuffer
  By design we exclude possibility of dropped
  messages in CircularBuffer because the
  size of SlotAllocator is smaller or less
  than CircularBuffer size.

  Size of score::cpp::CircularBuffer
end note

note right of LogRecord
  Test strategy:
  Tested in data_router
end note

note bottom of FileOutputBackend
  Test strategy:
  Test just a glue code and
  not underlying classes
  Inject SlotDrainer with
  mocked OSAL
  Use MessageBuilderMock

  Only place that messages
  may be dropped for the
  reason of failure to get buffer
  from SlotAllocator
end note

note bottom of BackendLogMock
  Mock
end note

note bottom of LogRecord
  Note..

  Used for data types
  that differ from message to message
end note

note as SyncNote
  Synchronised access only: guarded by SlotDrainer context mutex.
end note

SyncNote .. IMessageBuilder
SyncNote .. NonBlockingWriter

@enduml
